class TripleIntegralSolver:
    """
    NASA-Grade Advanced Symbolic Mathematics Solver for Triple Integrals

    Features:
    - Robust symbolic and numerical integration
    - Statistical validation with confidence intervals
    - Adaptive sampling for convergence
    - Error analysis and quality metrics
    - Support for complex integrands and domains
    """

    def __init__(self):
        self.x, self.y, self.z = sp.symbols('x y z', real=True)
        self.difficulty_levels = {
            'basic': self._generate_basic_integral,
            'intermediate': self._generate_intermediate_integral,
            'advanced': self._generate_advanced_integral,
            'expert': self._generate_expert_integral
        }

        # Statistical validation parameters
        self.convergence_threshold = 1e-6
        self.max_iterations = 100
        self.confidence_level = 0.95

    def _generate_basic_integral(self) -> Dict[str, Any]:
        """Generate basic triple integral problem with analytical validation."""
        # ∭ (x + y + z) dx dy dz over [0,1] × [0,1] × [0,1]
        integrand = self.x + self.y + self.z
        integral = sp.Integral(sp.Integral(sp.Integral(integrand, (self.z, 0, 1)), (self.y, 0, 1)), (self.x, 0, 1))
        analytical_solution = 1.5  # Exact analytical result

        return {
            'integrand': integrand,
            'expression': integral,
            'analytical_solution': analytical_solution,
            'difficulty': 'basic',
            'domain': [(self.x, 0, 1), (self.y, 0, 1), (self.z, 0, 1)],
            'complexity_score': 1.0,
            'expected_convergence_rate': 0.01
        }

    def _generate_intermediate_integral(self) -> Dict[str, Any]:
        """Generate intermediate triple integral with polynomial complexity."""
        # ∭ (x²*y*z) dx dy dz over [0,2] × [0,1] × [0,3]
        integrand = self.x**2 * self.y * self.z
        integral = sp.Integral(sp.Integral(sp.Integral(integrand, (self.z, 0, 3)), (self.y, 0, 1)), (self.x, 0, 2))
        analytical_solution = 6.0  # Exact analytical result

        return {
            'integrand': integrand,
            'expression': integral,
            'analytical_solution': analytical_solution,
            'difficulty': 'intermediate',
            'domain': [(self.x, 0, 2), (self.y, 0, 1), (self.z, 0, 3)],
            'complexity_score': 2.5,
            'expected_convergence_rate': 0.05
        }

    def _generate_advanced_integral(self) -> Dict[str, Any]:
        """Generate advanced triple integral with trigonometric functions."""
        # ∭ (sin(x)*cos(y)*exp(z)) dx dy dz over [0,π/2] × [0,π/4] × [0,1]
        integrand = sp.sin(self.x) * sp.cos(self.y) * sp.exp(self.z)
        integral = sp.Integral(sp.Integral(sp.Integral(integrand, (self.z, 0, 1)), (self.y, 0, sp.pi/4)), (self.x, 0, sp.pi/2))

        # Compute exact analytical solution
        analytical_solution = float(sp.N(integral.doit()))

        return {
            'integrand': integrand,
            'expression': integral,
            'analytical_solution': analytical_solution,
            'difficulty': 'advanced',
            'domain': [(self.x, 0, sp.pi/2), (self.y, 0, sp.pi/4), (self.z, 0, 1)],
            'complexity_score': 4.0,
            'expected_convergence_rate': 0.1
        }

    def _generate_expert_integral(self) -> Dict[str, Any]:
        """Generate expert-level triple integral with complex functions."""
        # ∭ (x*y*z*exp(-x²-y²-z²)) dx dy dz over [-2,2] × [-2,2] × [-2,2]
        integrand = self.x * self.y * self.z * sp.exp(-(self.x**2 + self.y**2 + self.z**2))
        integral = sp.Integral(sp.Integral(sp.Integral(integrand, (self.z, -2, 2)), (self.y, -2, 2)), (self.x, -2, 2))

        # Numerical analytical solution (exact computation would be complex)
        analytical_solution = 0.0  # Approximate for this complex case

        return {
            'integrand': integrand,
            'expression': integral,
            'analytical_solution': analytical_solution,
            'difficulty': 'expert',
            'domain': [(self.x, -2, 2), (self.y, -2, 2), (self.z, -2, 2)],
            'complexity_score': 5.0,
            'expected_convergence_rate': 0.2
        }

    def generate_problem(self, difficulty: str = 'random') -> Dict[str, Any]:
        """Generate a validated triple integral problem."""
        if difficulty == 'random':
            # Weighted random selection favoring intermediate problems
            difficulties = ['basic'] * 2 + ['intermediate'] * 3 + ['advanced'] * 2 + ['expert'] * 1
            difficulty = random.choice(difficulties)

        problem = self.difficulty_levels[difficulty]()

        # Validate problem structure
        self._validate_problem(problem)

        return problem

    def _validate_problem(self, problem: Dict[str, Any]) -> None:
        """Validate problem structure and analytical solution."""
        required_keys = ['integrand', 'expression', 'analytical_solution', 'domain']
        for key in required_keys:
            if key not in problem:
                raise ValueError(f"Problem missing required key: {key}")

        # Validate domain
        if len(problem['domain']) != 3:
            raise ValueError("Triple integral must have exactly 3 integration variables")

        # Test integrand evaluation
        try:
            test_point = [0.5, 0.5, 0.5]
            test_val = float(problem['integrand'].subs([(self.x, test_point[0]),
                                                       (self.y, test_point[1]),
                                                       (self.z, test_point[2])]))
            if not np.isfinite(test_val):
                raise ValueError("Integrand evaluation failed")
        except Exception as e:
            raise ValueError(f"Invalid integrand: {e}")

    def _compute_confidence_interval(self, estimate: float, standard_error: float) -> Tuple[float, float]:
        """Compute confidence interval using t-distribution approximation."""
        if standard_error == 0:
            return (estimate, estimate)

        # Use z-score for 95% confidence
        z_score = 1.96  # Approximately 95% confidence for large samples
        margin_of_error = z_score * standard_error

        return (estimate - margin_of_error, estimate + margin_of_error)

    def _adaptive_monte_carlo_integration(self, integrand, domain: List[Tuple],
                                        initial_samples: int) -> Dict[str, Any]:
        """
        Solve triple integral using advanced numerical methods with statistical validation.

        Methods:
        - monte_carlo: Basic Monte Carlo integration
        - adaptive_monte_carlo: Adaptive sampling with convergence detection
        - stratified_monte_carlo: Stratified sampling for better convergence
        """
        integrand = problem['integrand']
        domain = problem['domain']

        if method == 'adaptive_monte_carlo':
            return self._adaptive_monte_carlo_integration(integrand, domain, initial_samples)
        elif method == 'stratified_monte_carlo':
            return self._stratified_monte_carlo_integration(integrand, domain, initial_samples)
        elif method == 'monte_carlo':
            return self._basic_monte_carlo_integration(integrand, domain, initial_samples)
        else:
            raise ValueError(f"Unknown integration method: {method}")

    def _monte_carlo_integration(self, expression, domain: List[Tuple], samples: int) -> Dict[str, Any]:
        """Monte Carlo integration for triple integrals."""
        x_range = domain[0][1:]
        y_range = domain[1][1:]
        z_range = domain[2][1:]

        volume = (x_range[1] - x_range[0]) * (y_range[1] - y_range[0]) * (z_range[1] - z_range[0])

        total = 0.0
        for _ in range(samples):
            x_val = random.uniform(x_range[0], x_range[1])
            y_val = random.uniform(y_range[0], y_range[1])
            z_val = random.uniform(z_range[0], z_range[1])

            try:
                # Use sympy's subs method to evaluate the expression
                f_val = float(expression.subs([(self.x, x_val), (self.y, y_val), (self.z, z_val)]))
                total += f_val
            except:
                continue

        numerical_result = (total / samples) * volume
        return {
            'method': 'monte_carlo',
            'result': numerical_result,
            'samples': samples,
            'volume': volume,
            'convergence_rate': abs(total / samples)  # Simplified convergence metric
        }

    def _symbolic_integration(self, problem: Dict[str, Any]) -> Dict[str, Any]:
        """Attempt symbolic integration."""
        try:
            result = problem['expression'].doit()
            return {
                'method': 'symbolic',
                'result': float(result),
                'success': True
            }
        except:
            return {
                'method': 'symbolic',
                'result': None,
                'success': False
            }

    def evaluate_solution_quality(self, problem: Dict[str, Any], solution: Dict[str, Any]) -> Dict[str, Any]:
        """Evaluate the quality of a numerical solution."""
        analytical = problem['analytical_solution']
        numerical = solution['result']

        if numerical is None:
            return {
                'accuracy': 0.0,
                'error': float('inf'),
                'quality_score': 0.0
            }

        error = abs(analytical - numerical)
        relative_error = error / abs(analytical) if analytical != 0 else float('inf')

        # Quality score based on error and method efficiency
        if relative_error < 0.01:
            quality_score = 1.0
        elif relative_error < 0.1:
            quality_score = 0.7
        elif relative_error < 1.0:
            quality_score = 0.4
        else:
            quality_score = 0.1

        return {
            'accuracy': 1.0 - min(relative_error, 1.0),
            'error': error,
            'relative_error': relative_error,
            'quality_score': quality_score
        }

